{"version":3,"sources":["../src/functions/lazy.ts","../src/functions/range.ts","../src/functions/calculateShardId.ts","../src/JSONEncodable.ts","../src/Equatable.ts"],"sourcesContent":["/**\n * Lazy is a wrapper around a value that is computed lazily. It is useful for\n * cases where the value is expensive to compute and the computation may not\n * be needed at all.\n *\n * @param cb - The callback to lazily evaluate\n * @typeParam T - The type of the value\n * @example\n * ```ts\n * const value = lazy(() => computeExpensiveValue());\n * ```\n */\n// eslint-disable-next-line promise/prefer-await-to-callbacks\nexport function lazy<T>(cb: () => T): () => T {\n\tlet defaultValue: T;\n\t// eslint-disable-next-line promise/prefer-await-to-callbacks\n\treturn () => (defaultValue ??= cb());\n}\n","/**\n * Options for creating a range\n */\nexport interface RangeOptions {\n\t/**\n\t * The end of the range (exclusive)\n\t */\n\tend: number;\n\t/**\n\t * The start of the range (inclusive)\n\t */\n\tstart: number;\n\t/**\n\t * The amount to increment by\n\t *\n\t * @defaultValue `1`\n\t */\n\tstep?: number;\n}\n\n/**\n * A generator to yield numbers in a given range\n *\n * @remarks\n * This method is end-exclusive, for example the last number yielded by `range(5)` is 4. If you\n * prefer for the end to be included add 1 to the range or `end` option.\n * @param range - A number representing the the range to yield (exclusive) or an object with start, end and step\n * @example\n * Basic range\n * ```ts\n * for (const number of range(5)) {\n *  console.log(number);\n * }\n * // Prints 0, 1, 2, 3, 4\n * ```\n * @example\n * Range with a step\n * ```ts\n * for (const number of range({ start: 3, end: 10, step: 2 })) {\n * \tconsole.log(number);\n * }\n * // Prints 3, 5, 7, 9\n * ```\n */\nexport function* range(range: RangeOptions | number) {\n\tlet rangeEnd: number;\n\tlet start = 0;\n\tlet step = 1;\n\n\tif (typeof range === 'number') {\n\t\trangeEnd = range;\n\t} else {\n\t\tstart = range.start;\n\t\trangeEnd = range.end;\n\t\tstep = range.step ?? 1;\n\t}\n\n\tfor (let index = start; index < rangeEnd; index += step) {\n\t\tyield index;\n\t}\n}\n","export function calculateShardId(guildId: string, shardCount: number) {\n\treturn Number((BigInt(guildId) >> 22n) % BigInt(shardCount));\n}\n","/**\n * Represents an object capable of representing itself as a JSON object\n *\n * @typeParam T - The JSON type corresponding to {@link JSONEncodable.toJSON} outputs.\n */\nexport interface JSONEncodable<T> {\n\t/**\n\t * Transforms this object to its JSON format\n\t */\n\ttoJSON(): T;\n}\n\n/**\n * Indicates if an object is encodable or not.\n *\n * @param maybeEncodable - The object to check against\n */\nexport function isJSONEncodable(maybeEncodable: unknown): maybeEncodable is JSONEncodable<unknown> {\n\treturn maybeEncodable !== null && typeof maybeEncodable === 'object' && 'toJSON' in maybeEncodable;\n}\n","/**\n * Represents a structure that can be checked against another\n * given structure for equality\n *\n * @typeParam T - The type of object to compare the current object to\n */\nexport interface Equatable<T> {\n\t/**\n\t * Whether or not this is equal to another structure\n\t */\n\tequals(other: T): boolean;\n}\n\n/**\n * Indicates if an object is equatable or not.\n *\n * @param maybeEquatable - The object to check against\n */\nexport function isEquatable(maybeEquatable: unknown): maybeEquatable is Equatable<unknown> {\n\treturn maybeEquatable !== null && typeof maybeEquatable === 'object' && 'equals' in maybeEquatable;\n}\n"],"mappings":";;;;AAaO,SAASA,KAAQC,IAAsB;AAC7C,MAAIC;AAEJ,SAAO,MAAOA,iBAAiBD,GAAAA;AAChC;AAJgBD;;;AC+BT,UAAUG,MAAMA,QAA8B;AACpD,MAAIC;AACJ,MAAIC,QAAQ;AACZ,MAAIC,OAAO;AAEX,MAAI,OAAOH,WAAU,UAAU;AAC9BC,eAAWD;EACZ,OAAO;AACNE,YAAQF,OAAME;AACdD,eAAWD,OAAMI;AACjBD,WAAOH,OAAMG,QAAQ;EACtB;AAEA,WAASE,QAAQH,OAAOG,QAAQJ,UAAUI,SAASF,MAAM;AACxD,UAAME;EACP;AACD;AAhBiBL;;;AC5CV,SAASM,iBAAiBC,SAAiBC,YAAoB;AACrE,SAAOC,QAAQC,OAAOH,OAAAA,KAAY,OAAOG,OAAOF,UAAAA,CAAAA;AACjD;AAFgBF;;;ACiBT,SAASK,gBAAgBC,gBAAmE;AAClG,SAAOA,mBAAmB,QAAQ,OAAOA,mBAAmB,YAAY,YAAYA;AACrF;AAFgBD;;;ACCT,SAASE,YAAYC,gBAA+D;AAC1F,SAAOA,mBAAmB,QAAQ,OAAOA,mBAAmB,YAAY,YAAYA;AACrF;AAFgBD;","names":["lazy","cb","defaultValue","range","rangeEnd","start","step","end","index","calculateShardId","guildId","shardCount","Number","BigInt","isJSONEncodable","maybeEncodable","isEquatable","maybeEquatable"]}